import { supabase } from '@/integrations/supabase/client';
import { withRetry, classifyError, formatErrorForUser } from './edgeFunctionRetryService';

export interface ImageGenerationParams {
  text: string;
  style?: 'professional' | 'modern' | 'minimalist' | 'creative';
  aspectRatio?: '1:1' | '16:9' | '9:16';
  contentFormat?: 'feed' | 'stories' | 'reels';
  contentType?: string;
  width?: number;
  height?: number;
}

interface ImageGenerationResponse {
  imageUrl: string;
}

export const generateContentImage = async (params: ImageGenerationParams): Promise<ImageGenerationResponse> => {
  const { text, style = 'modern', aspectRatio = '1:1', contentFormat = 'feed', contentType = 'educational', width, height } = params;

  // Get exact dimensions based on format
  const dimensions = width && height ? { width, height } : getFormatDimensions(contentFormat);
  
  // Use the contextual prompt directly - it's already generated by contextualImageService
  // Only fallback to basic prompt if text is empty or too short
  const optimizedPrompt = text && text.length > 20 
    ? text 
    : createImagePrompt(text || 'professional modern content', style, contentFormat, contentType);

  try {
    console.log('ðŸŽ¨ [generate-image] Starting image generation...');
    console.log('ðŸ“ [generate-image] Prompt preview:', optimizedPrompt.substring(0, 100) + '...');
    
    // Use retry wrapper for automatic retries with exponential backoff
    const result = await withRetry(
      'generate-image',
      async () => {
        const { data, error } = await supabase.functions.invoke('generate-image', {
          body: {
            prompt: optimizedPrompt,
            size: `${dimensions.width}x${dimensions.height}`
          }
        });

        if (error) {
          console.error('âŒ [generate-image] Supabase function error:', error);
          throw error;
        }

        if (!data?.success) {
          throw new Error(data?.error || 'Falha na geraÃ§Ã£o da imagem');
        }

        return data;
      },
      { maxRetries: 2, baseDelayMs: 1500 }
    );

    console.log('âœ… [generate-image] Image generated successfully');
    return { imageUrl: result.imageUrl };

  } catch (error: any) {
    const classifiedError = classifyError(error, 'generate-image');
    console.error('ðŸš¨ [generate-image] Final error:', {
      type: classifiedError.errorType,
      message: classifiedError.message,
      userMessage: formatErrorForUser(classifiedError)
    });
    
    // Return fallback image for better UX
    const fallbackUrl = getFallbackImage(contentType, contentFormat);
    console.log('ðŸ”„ [generate-image] Using fallback image');
    
    return { imageUrl: fallbackUrl };
  }
};

// Helper functions
const getFormatDimensions = (format: string): { width: number; height: number } => {
  switch (format) {
    case 'stories':
      return { width: 1024, height: 1792 }; // OpenAI supported vertical
    case 'reels':
      return { width: 1024, height: 1792 }; // OpenAI supported vertical
    case 'feed':
    default:
      return { width: 1024, height: 1024 }; // OpenAI supported square
  }
};

const createImagePrompt = (text: string, style: string, format: string, type: string): string => {
  // Clean text for better prompt
  const cleanText = text.replace(/[ðŸ§µðŸ“ŠðŸ’¡âš¡ðŸ”¥âœ¨ðŸ’°ðŸ“ˆðŸ“‰ðŸŽ¯ðŸš€]/g, '').trim();
  
  const styleDescriptors = {
    professional: 'professional, clean, business-like',
    modern: 'modern, sleek, contemporary',
    minimalist: 'minimalist, simple, clean lines',
    creative: 'creative, artistic, dynamic'
  };

  const typeDescriptors = {
    educational: 'educational, informative, professional setting',
    motivational: 'inspiring, energetic, uplifting',
    tutorial: 'step-by-step, clear, instructional',
    business: 'corporate, professional, success-oriented',
    lifestyle: 'lifestyle, everyday, relatable'
  };

  const baseStyle = styleDescriptors[style as keyof typeof styleDescriptors] || styleDescriptors.modern;
  const typeStyle = typeDescriptors[type as keyof typeof typeDescriptors] || typeDescriptors.educational;

  return `High-quality photograph: ${typeStyle}, ${baseStyle}, realistic lighting, no text overlay, ${format === 'stories' ? 'vertical composition' : 'square composition'}, professional photography`;
};

const getFallbackImage = (contentType: string, format: string): string => {
  const baseUrl = 'https://images.unsplash.com';
  const dimensions = format === 'stories' ? '1024x1792' : '1024x1024';
  
  const fallbackCategories = {
    educational: 'study,learning,books',
    motivational: 'success,motivation,achievement',
    tutorial: 'workspace,computer,tutorial',
    business: 'business,office,professional',
    lifestyle: 'lifestyle,modern,clean',
    default: 'abstract,modern,minimal'
  };

  const category = fallbackCategories[contentType as keyof typeof fallbackCategories] || fallbackCategories.default;
  return `${baseUrl}/${dimensions}/?${category}&auto=format&fit=crop`;
};

// Profile image conversion utility
export const convertProfileImageToUrl = (file: File): Promise<string> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      const result = e.target?.result;
      if (typeof result === 'string') {
        resolve(result);
      } else {
        reject(new Error('Failed to convert file to URL'));
      }
    };
    reader.onerror = () => reject(new Error('Failed to read file'));
    reader.readAsDataURL(file);
  });
};